// Generated by CoffeeScript 1.8.0
'use strict';
var Builtin, Curried, Env, Error, Lambda, Symbol, add_globals, bracket_balance, colors, evaluate, expand, exports, global_env, isa, macro_table, read_line, to_parse, to_string, _and, _append, _begin, _cond, _cons, _define, _definemacro, _deletemacro, _else, _if, _lambda, _local, _or, _quasiquote, _quote, _ref, _ref1, _ref2, _set, _unquote, _unquotesplicing,
  __slice = [].slice;

if (typeof exports !== "undefined" && exports !== null) {
  colors = require('colors/safe');
} else {
  exports = {};
}

exports.colors = false;

exports.curry = true;

isa = function() {
  var classes, instance;
  instance = arguments[0], classes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return classes.some(function(c) {
    return instance instanceof c;
  });
};

Symbol = (function() {
  function Symbol(value) {
    this.value = value;
  }

  Symbol.prototype.inspect = function(depth) {
    return "'" + this.value;
  };

  Symbol.table = {};

  Symbol.sym = function(str_repr) {
    var _ref;
    return Symbol.table[str_repr] = (_ref = Symbol.table[str_repr]) != null ? _ref : new Symbol(str_repr);
  };

  return Symbol;

})();

_ref = 'if set! define lambda begin cond else local and or quote unquote'.split(' ').map(Symbol.sym), _if = _ref[0], _set = _ref[1], _define = _ref[2], _lambda = _ref[3], _begin = _ref[4], _cond = _ref[5], _else = _ref[6], _local = _ref[7], _and = _ref[8], _or = _ref[9], _quote = _ref[10], _unquote = _ref[11];

_ref1 = 'unquote-splicing quasiquote append cons define-macro delete-macro'.split(' ').map(Symbol.sym), _unquotesplicing = _ref1[0], _quasiquote = _ref1[1], _append = _ref1[2], _cons = _ref1[3], _definemacro = _ref1[4], _deletemacro = _ref1[5];

Builtin = (function() {
  function Builtin(func, expected_args) {
    this.func = func;
    this.expected_args = expected_args != null ? expected_args : -1;
    if (this.expected_args === -1) {
      this.expected_args = func.length;
    }
  }

  Builtin.prototype.call = function(args) {
    if ((this.expected_args > args.length) && this.expected_args !== Infinity) {
      if (!exports.curry) {
        throw new Error("Function expects " + this.expected_args + " arguments, not " + (to_string(args)));
      }
      return new Curried(this, args);
    } else if ((this.expected_args !== args.length) && this.expected_args !== Infinity) {
      throw new Error("Function expects " + this.expected_args + " arguments, not " + (to_string(args)));
    } else {
      return this.func.apply(null, args);
    }
  };

  return Builtin;

})();

Lambda = (function() {
  function Lambda(params, body, env) {
    this.params = params;
    this.body = body;
    this.env = env;
    this.expected_args = params.length;
  }

  Lambda.prototype.call = function(args) {
    if (this.expected_args > args.length) {
      if (!exports.curry) {
        throw new Error("Function arguments " + (to_string(args)) + " don't match " + (to_string(this.params)));
      }
      return new Curried(this, args);
    } else if (this.expected_args !== args.length) {
      throw new Error("Function arguments " + (to_string(args)) + " don't match " + (to_string(this.params)));
    } else {
      return evaluate(this.body, new Env(this.params, args, this.env));
    }
  };

  return Lambda;

})();

Curried = (function() {
  function Curried(parent, fixed_args) {
    this.parent = parent;
    this.fixed_args = fixed_args;
    this.expected_args = parent.expected_args - fixed_args.length;
    if (isa(parent, Curried)) {
      this.fixed_args = parent.fixed_args.concat(fixed_args);
      this.parent = parent.parent;
    }
  }

  Curried.prototype.call = function(args) {
    if (this.expected_args > args.length) {
      return new Curried(this.parent, this.fixed_args.concat(args));
    } else {
      return this.parent.call(this.fixed_args.concat(args));
    }
  };

  return Curried;

})();

Env = (function() {
  function Env(params, args, outer) {
    var i, param, _i, _len;
    if (params == null) {
      params = [];
    }
    if (args == null) {
      args = [];
    }
    this.outer = outer;
    this.dict = {};
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      param = params[i];
      this.dict[param.value] = args[i];
    }
  }

  Env.prototype.find = function(sym) {
    var _ref2;
    if (sym.value in this.dict) {
      return this;
    }
    return (function() {
      var _ref3;
      if ((_ref2 = (_ref3 = this.outer) != null ? _ref3.find(sym) : void 0) != null) {
        return _ref2;
      } else {
        throw new Error("Could not find Symbol " + (to_string(sym)));
      }
    }).call(this);
  };

  Env.prototype.get_value = function(sym) {
    return this.find(sym).dict[sym.value];
  };

  Env.prototype.set_value = function(sym, val) {
    return this.find(sym).dict[sym.value] = val;
  };

  Env.prototype.add_value = function(sym, val) {
    return this.dict[sym.value] = val;
  };

  return Env;

})();

add_globals = function(env) {
  var equal, name, to_add, value;
  to_add = {
    'eval': function(x) {
      return evaluate(x);
    },
    'void': void 0,
    'true': true,
    'false': false,
    'empty': [],
    'get-definition': function(f) {
      if (!isa(f, Lambda)) {
        throw new Error("Cannot get definition of " + (to_string(f)));
      }
      return [_lambda, f.params, f.body];
    },
    'gensym': function() {
      return Symbol.sym(Math.random().toString(36).substring(2));
    },
    'display': function(x) {
      return console.log(to_string(x));
    },
    'to-string': function(x) {
      if (typeof x === 'string') {
        return x;
      } else {
        return to_string(x);
      }
    },
    'procedure?': function(x) {
      return isa(x, Builtin, Lambda, Curried);
    },
    'list?': function(x) {
      return isa(x, Array);
    },
    'symbol?': function(x) {
      return isa(x, Symbol);
    },
    'string?': function(x) {
      return typeof x === 'string';
    },
    'number?': function(x) {
      return typeof x === 'number';
    },
    'boolean?': function(x) {
      return typeof x === 'boolean';
    },
    'not': function(x) {
      if (!(typeof x === 'boolean')) {
        throw new Error("not expected boolean, not " + (to_string(x)));
      }
      return !x;
    },
    'same?': function(x, y) {
      return x === y;
    },
    'equal?': equal = function(x, y) {
      var i, type, _i, _ref2;
      if (!((type = typeof x) === typeof y)) {
        return false;
      }
      if ((type === 'object') && x.constructor === y.constructor && x instanceof Array) {
        if (!(x.length === y.length)) {
          return false;
        }
        if (!equal(x[i], y[i])) {
          for (i = _i = 0, _ref2 = x.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
            return false;
          }
        }
        return true;
      }
      return x === y;
    },
    'list': new Builtin((function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return args;
    }), Infinity),
    'length': function(l) {
      if (!isa(l, Array)) {
        throw new Error("length expected a list, not " + (to_string(l)));
      }
      return l.length;
    },
    'first': function(l) {
      if (!isa(l, Array)) {
        throw new Error("first expected a list, not " + (to_string(l)));
      }
      return l[0];
    },
    'rest': function(l) {
      if (!isa(l, Array)) {
        throw new Error("rest expected a list, not " + (to_string(l)));
      }
      return l.slice(1);
    },
    'cons': function(x, l) {
      if (!(l instanceof Array)) {
        throw new Error("cons expected the second argument to be a list, not " + (to_string(l)));
      }
      return [x].concat(l);
    },
    'append': function(x, y) {
      if (!(x instanceof Array && y instanceof Array)) {
        throw new Error("first expected list, not " + (to_string(l)));
      }
      return x.concat(y);
    },
    '<': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("< expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return x < y;
    },
    '=': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("= expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return x === y;
    },
    '+': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("+ expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return x + y;
    },
    '-': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("- expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return x - y;
    },
    '/': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("/ expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return x / y;
    },
    '*': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("* expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return x * y;
    },
    'quotient': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("quotient expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return int(x / y);
    },
    'max': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("max expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return Math.max(x, y);
    },
    'min': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("min expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return Math.min(x, y);
    },
    'expt': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("expt expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return Math.pow(x, y);
    },
    'round': function(x) {
      if (!(typeof x === 'number')) {
        throw Error("round expected a numbers, not " + (to_string(x)));
      }
      return Math.round(x);
    },
    'remainder': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'number'))) {
        throw Error("remainder expected two numbers, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return x % y;
    },
    'string-append': function(x, y) {
      var _ref2;
      if (!((typeof x === (_ref2 = typeof y) && _ref2 === 'string'))) {
        throw Error("string-append expected two strings, not " + (to_string(x)) + " and " + (to_string(y)));
      }
      return x.concat(y);
    },
    'substring': function(x, y, z) {
      var _ref2;
      if (!(typeof x === 'string' && (typeof y === (_ref2 = typeof z) && _ref2 === 'number'))) {
        throw Error("substring expects a string and two numbers");
      }
      return x.substr(y, z - y);
    },
    'string-length': function(x) {
      if (!(typeof x === 'string')) {
        throw Error("string-length expected one strings, not " + (to_string(x)));
      }
      return x.length;
    },
    'error': function(x) {
      if (!(typeof x === 'string')) {
        throw new Error("error expected a string, not " + (to_string(x)));
      }
      throw new Error(x);
    },
    'print': function(x) {
      if (!(typeof x === 'string')) {
        throw new Error("print expected a string, not " + (to_string(x)));
      }
      return console.log(x);
    }
  };
  for (name in to_add) {
    value = to_add[name];
    env.dict[name] = typeof value === 'function' ? new Builtin(value) : value;
  }
  return env;
};

Error = (function() {
  function Error(message) {
    this.message = message;
  }

  Error.check = function(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  };

  return Error;

})();

_ref2 = ['', 0], to_parse = _ref2[0], bracket_balance = _ref2[1];

read_line = function(line) {
  var atom, parse, to_return, tokenize, _ref3, _ref4, _ref5;
  tokenize = function(string) {
    return {
      _comments: /^\s*;[^\n]*(\n\s*|$)/,
      _tokenizer: /^\s*(,@|[()',`]|"(\\.|[^\\"])*"|[^\s)]*)\s*/,
      _remaining: string,
      next: function() {
        var next_token;
        while (this._remaining.length > 0) {
          if (this._remaining.match(this._comments, '') != null) {
            this._remaining = this._remaining.replace(this._comments, '');
            continue;
          }
          next_token = this._remaining.match(this._tokenizer)[0].trim();
          this._remaining = this._remaining.replace(this._tokenizer, '');
          return next_token;
        }
        return null;
      }
    };
  };
  parse = function(iterator, next_token) {
    var L, token, _ref3;
    _ref3 = [next_token != null ? next_token : iterator.next(), []], token = _ref3[0], L = _ref3[1];
    switch (token) {
      case null:
        return null;
      case '(':
        while ((token = iterator.next())) {
          if (token === ')') {
            return L;
          }
          L.push(parse(iterator, token));
        }
        break;
      case ')':
        throw new Error('Unexpected closing bracket');
        break;
      case "'":
        return [_quote, parse(iterator)];
      case "`":
        return [_quasiquote, parse(iterator)];
      case ",":
        return [_unquote, parse(iterator)];
      case ",@":
        return [_unquotesplicing, parse(iterator)];
      default:
        return atom(token);
    }
  };
  atom = function(token) {
    if (/^"(\\.|[^\\"])*"$/.test(token)) {
      return token.slice(1, -1);
    }
    if (/^[+-]?([1-9]\d*|0)(\.\d+)?$/.test(token)) {
      return Number(token);
    }
    if (/^(true|True|#t)$/.test(token)) {
      return true;
    }
    if (/^(false|False|#f)$/.test(token)) {
      return false;
    }
    return Symbol.sym(token);
  };
  line = line.replace(/\[|{/g, '(').replace(/\]|}/g, ')');
  to_parse += line;
  bracket_balance += ((_ref3 = line.match(/\(/g)) != null ? _ref3 : []).length - ((_ref4 = line.match(/\)/g)) != null ? _ref4 : []).length;
  if (bracket_balance !== 0) {
    return null;
  }
  _ref5 = ['', 0, parse(tokenize(to_parse))], to_parse = _ref5[0], bracket_balance = _ref5[1], to_return = _ref5[2];
  return to_return;
};

macro_table = {};

expand = function(x) {
  var args, body, exp, expand_quasiquote, func, v, _def, _ref3, _ref4;
  expand_quasiquote = function(x) {
    if (!(x instanceof Array) || (x.length === 0)) {
      return [_quote, x];
    } else if (x[0] === _unquote) {
      return x[1];
    } else if ((x[0] instanceof Array) && (x[0].length > 0) && (x[0][0] === _unquotesplicing)) {
      return [_append, x[0][1], expand_quasiquote(x.slice(1))];
    } else {
      return [_cons, expand_quasiquote(x[0]), expand_quasiquote(x.slice(1))];
    }
  };
  if (!(x instanceof Array)) {
    return x;
  }
  if (x[0] === _deletemacro) {
    delete macro_table[x[1].value];
    return void 0;
  } else if (((_ref3 = x[0]) === _define || _ref3 === _definemacro)) {
    _def = x[0], v = x[1], body = x[2];
    if (v instanceof Array) {
      _ref4 = [v[0], v.slice(1)], func = _ref4[0], args = _ref4[1];
      return expand([_def, func, [_lambda, args, body]]);
    } else {
      exp = expand(x[2]);
      if (_def === _definemacro) {
        macro_table[v.value] = evaluate(exp);
        return void 0;
      } else {
        return [_define, v, exp];
      }
    }
  } else if (x[0] === _quote) {
    return x;
  } else if (x[0] === _quasiquote) {
    return expand_quasiquote(x[1]);
  } else if (x[0].value in macro_table) {
    return expand(macro_table[x[0].value].call(x.slice(1)));
  } else {
    return x.map(expand);
  }
};

evaluate = function(x, env) {
  var arg, args, body, cond, conds, definition, definitions, e, expr, exprs, func, if_false, if_true, params, symbol, val, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _p, _ref10, _ref11, _ref12, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
  if (env == null) {
    env = global_env;
  }
  try {
    while (true) {
      if (x instanceof Symbol) {
        return env.get_value(x);
      } else if (!(x instanceof Array) || (x == null)) {
        return x;
      } else {
        switch (x[0]) {
          case _quote:
            Error.check(x.length > 1, "quote expects an argument");
            arg = x.slice(1)[0];
            return arg;
          case _if:
            Error.check(x.length === 4, "if expects three arguments");
            _ref3 = x.slice(1), cond = _ref3[0], if_true = _ref3[1], if_false = _ref3[2];
            cond = evaluate(cond, env);
            Error.check(typeof (cond = evaluate(cond, env)) === 'boolean', "if expects a boolean, not " + cond);
            x = cond ? if_true : if_false;
            break;
          case _set:
            Error.check(x.length === 3, "set! expects two arguments");
            _ref4 = x.slice(1), symbol = _ref4[0], value = _ref4[1];
            Error.check(isa(symbol, Symbol), "set! expects a symbol, not " + (to_string(symbol)));
            env.set_value(symbol, evaluate(value, env));
            return void 0;
          case _define:
            Error.check(x.length === 3, "define expects two arguments");
            _ref5 = x.slice(1), symbol = _ref5[0], value = _ref5[1];
            Error.check(isa(symbol, Symbol), "define expects a symbol, not " + (to_string(symbol)));
            env.add_value(symbol, evaluate(value, env));
            return void 0;
          case _lambda:
            Error.check(x.length === 3, "lambda expects two arguments");
            _ref6 = x.slice(1), params = _ref6[0], body = _ref6[1];
            Error.check(params.every(function(s) {
              return isa(s, Symbol);
            }), "lambda expects parameters to be a list of symbols, not " + (to_string(params)));
            return new Lambda(params, body, env);
          case _begin:
            _ref7 = x.slice(1), exprs = 2 <= _ref7.length ? __slice.call(_ref7, 0, _i = _ref7.length - 1) : (_i = 0, []), x = _ref7[_i++];
            for (_j = 0, _len = exprs.length; _j < _len; _j++) {
              expr = exprs[_j];
              evaluate(expr, env);
            }
            break;
          case _cond:
            conds = x.slice(1);
            Error.check(conds.every(function(c) {
              return c.length === 2;
            }), "expected a list of (<cond> <value>) pairs");
            for (_k = 0, _len1 = conds.length; _k < _len1; _k++) {
              _ref8 = conds[_k], cond = _ref8[0], expr = _ref8[1];
              if (cond === _else) {
                x = expr;
                break;
              }
              Error.check(typeof (cond = evaluate(cond, env)) === 'boolean', "cond expects a boolean, not " + (to_string(cond)));
              if (cond) {
                x = expr;
                break;
              }
            }
            break;
          case _local:
            Error.check(x.length === 3, "local expects two arguments");
            _ref9 = x.slice(1), definitions = _ref9[0], x = _ref9[1];
            env = new Env([], [], env);
            for (_l = 0, _len2 = definitions.length; _l < _len2; _l++) {
              definition = definitions[_l];
              evaluate(definition, env);
            }
            break;
          case _and:
            _ref10 = x.slice(1), args = 2 <= _ref10.length ? __slice.call(_ref10, 0, _m = _ref10.length - 1) : (_m = 0, []), x = _ref10[_m++];
            for (_n = 0, _len3 = args.length; _n < _len3; _n++) {
              arg = args[_n];
              val = evaluate(arg, env);
              Error.check(typeof val === 'boolean', "and expects booleans, not " + (to_string(val)));
              if (!val) {
                return false;
              }
            }
            true;
            break;
          case _or:
            _ref11 = x.slice(1), args = 2 <= _ref11.length ? __slice.call(_ref11, 0, _o = _ref11.length - 1) : (_o = 0, []), x = _ref11[_o++];
            for (_p = 0, _len4 = args.length; _p < _len4; _p++) {
              arg = args[_p];
              val = evaluate(arg, env);
              Error.check(typeof val === 'boolean', "or expects booleans, not " + (to_string(val)));
              if (val) {
                return true;
              }
            }
            false;
            break;
          default:
            args = x.map(function(arg) {
              return evaluate(arg, env);
            });
            func = args.shift();
            Error.check(isa(func, Builtin, Lambda, Curried), "expected a function, not " + (to_string(func)));
            if (isa(func, Builtin) || isa(func, Curried) || func.expected_args !== args.length) {
              return func.call(args);
            }
            _ref12 = [func.body, new Env(func.params, args, func.env)], x = _ref12[0], env = _ref12[1];
        }
      }
    }
  } catch (_error) {
    e = _error;
    if (e instanceof Error) {
      throw new Error("" + e.message + "\n  in call to " + (to_string(x)));
    }
    throw e;
  }
};

to_string = function(x) {
  var c;
  c = function(string, color) {
    if (exports.colors) {
      return colors[color](string);
    } else {
      return string;
    }
  };
  switch (false) {
    case !isa(x, Array):
      return c("(" + (x.map(to_string).join(' ')) + ")", 'white');
    case !isa(x, Symbol):
      return c("'" + x.value, 'cyan');
    case !isa(x, Builtin):
      return c("{built-in function}", 'grey');
    case !isa(x, Lambda, Curried):
      return c("{user-defined function}", 'grey');
    case !isa(x, Error):
      return c("Error: " + x.message, 'red');
    case x !== null:
      return null;
    default:
      switch (typeof x) {
        case 'number':
          return c(x.toString(), 'yellow');
        case 'boolean':
          return c(x.toString(), 'magenta');
        case 'string':
          return c("\"" + x + "\"", 'green');
      }
  }
};

global_env = add_globals(new Env());

exports.read_line = read_line;

exports.evaluate = function(x) {
  var e;
  try {
    return evaluate(expand(x));
  } catch (_error) {
    e = _error;
    if (e instanceof Error) {
      return e;
    } else {
      return new Error("Panic! Javasc(heme|ript) error: " + e);
    }
  }
};

exports.to_string = to_string;

exports.pending_lines = function() {
  return to_parse;
};

exports.globals = global_env;
